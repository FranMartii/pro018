## 7689 - Definiciones de clase (3)

## Proyecto "maquina-expendedora-simple"

<img align="right" style="margin: 0 0 20px 20px" src="maquina.jpg">

Cierra BlueJ (en caso de que lo tuvieras abierto), ábrelo de nuevo y abre el proyecto `maquina-expendedora-simple`. 

## Parámetros

Los constructores y los métodos desempeñan papeles muy distintos en la vida de un objeto, pero la forma en que ambos reciben valores desde el exterior es la misma: a través de parámetros (recuerda que ya nos hemos topado brevemenete con los parámetros anteriormente). Los parámetros son variables que se definen en la cabecera de un constructor o de un método:

```java
public MaquinaExpendedoraSimple(int precioDelBillete, String origen, String destino)
```

Este constructor tiene tres parámetros: uno de tipo `int` y dos de tipo `String`. Los parámetros se emplean como una especie de mensajeros temporales, que transportan datos cuyo origen se sitúa fuera del constructor o método y que hacen que esos datos estén disponibles en el interior del constructor o método.

Cuando el usuario de BueJ introduce los tres valores que solicita el cuadro de diálogo que aparece cuando se crea una máquina expendedora y hace clic en el boton *Aceptar* dichos valores se almacenan inmediatamente en los parámetros `precioDelBillete`, `origen` y `destino` respectivamente.

Es importante tener en cuenta que un parámetro solo puede ser accedido (es decir, solo se puede leer o modificar su valor) dentro del cuerpo del constructor o del método que lo declare. Decimos que el *ámbito* de un parámetro está restringido al cuerpo del constructor o método en el que se declara. Por el contrario, el ámbito de un atributo es todo el conjunto de la definición de la clase por lo que puede accederse a ese atributo (se puede leer o modificar su valor) desde cualquier punto de la clase. 

Por tanto podemos concluir que el *ámbito de una variable* define la sección del código fuente desde la que se puede acceder a dicha variable. El diferente ámbito que tienen los atributos (toda la clase) y los parámetros (el método o constructor que los declara) es una diferencia muy importante entre estos dos tipos de variables.

Un concepto relacionado con el ámbito de las variables es el *tiempo de vida* de las mismas. El tiempo de vida de un parámetro está limitado a una única llamada a un constructor o método. Cuando se invoca un constructor o método, se crea espacio para cada uno de los parámetros y los valores que se proporcionan en el cuadro de diálogo se copian a dichos espacios. Una vez que el constructor o método ha completado su tarea, los parámetros desaparecen y los valores que contenían se pierden. En otras palabras, cuando el constructor o método ha terminado de ejecutarse, se elimina todo el espacio reservado para los parámetros.

Por el contrario, el tiempo de vida de un atributo coincide con el del objeto al que pertenece. Cuando se crea un objeto, se crean también los atributos del mismo, y estos existen mientras dure el tiempo de vida del objeto. De aquí se deduce que, si queremos poder acceder al precio de los billetes en cualquier punto de la clase deberemos almacenar el valor que hemos indicado para el parámetro `precioDelBillete` en algún lugar persistente, es decir en el atributo `precioBillete`.
En resumen, podemos decir que el *tiempo de vida de una variable* describe durante cuánto tiempo continúa existiendo la variable antes de ser destruida.

Al igual que cabía esperar que existiera una estrecha conexión entre un constructor y los atributos de una clase, también es de esperar que exista una estrecha conexión entre los parámetros del constructor y los atributos de esa clase, porque a menudo se necesitarán valores externos para configurar los valores iniciales de uno o más de estos atributos. Cuando así suceda, los tipos de parámetros se asemejarán estrechamente a los tipos de los atributos correspondientes. 

Una de las cosas que puede que hayas observado es que los nombres de variable que utilizamos para los atributos y para los parámetros tienen una estrecha conexión con el propósito de la variable. Nombres como `precioBillete`, `estacionOrigen` y `estacionDestino` nos proporcionan indicaciones útiles acerca de la información que se va a almacenar en estas variables. A su vez, facilita la comprensión de lo que pasa en el programa. Dado que tenemos una gran libertad a la hora de elegir los nombres de las variables, es conveniente optar por aquellos que proporcionen información relevante al programador que está leyendo el código fuente en lugar de elegir combinaciones arbitrarias e ininteligible de letras y números. Por eso, usar como nombre de un atributo `x`, `y` o `z`, por ejemplo, es una práctica que debemos evitar.


## Asignación

En el apartado anterior, hemos observado que en muchas ocasiones nos hace falta tomar el valor de corta duración contenido en un parámetro y almacenarlo en algún otro lugar más permanente como es un atributo. Para ello, el cuerpo del constructor contiene la siguiente *instrucción de asignación*:

``` java
precioBillete = precioDelBillete;
```

Las instrucciones de asignación se emplean con enorme frecuencia en programación como forma de almacenar un valor en una variable. Pueden reconocerse por la presencia de un operador de asignación, como `=` en el ejemplo anterior.  Las instrucciones de asignación funcionan tomando el valor que aparece en el lado derecho del operador y copiando dicho valor en la variable especificada en el lado izquierdo. 

Al lado derecho de la instrucción se le denomina *expresión*. En su forma más general, las expresiones son elementos que calculan un valor (por ejemplo, `3 + 4`), pero en este caso la expresión consiste en una sola variable (el parámetro `precioDelBillete`), cuyo valor se copia en la variable `precioBillete`.

Una regla relativa a las instrucciones de asignación es que el tipo de la expresión del lado derecho debe corresponderse con el tipo de la variable a la que se asigna. Esta regla implica que no podemos almacenar, por ejemplo, una expresión de tipo `int`  en una variable de tipo `String`.


## Métodos

La clase `MaquinaExpendedoraSimple` tiene cuatro métodos: `getPrecioBillete`, `getBalanceClienteActual`, `introducirDinero` e `imprimirBillete`. 

Los métodos Tienen dos partes: una *cabecera* y un *cuerpo*. Por ejemplo a continuación puedes ver la cabecera del método `getPrecioBillete`  precedida de un comentario descriptivo:

```java
    /**
     * Devuelve el precio del billete
     */
    public int getPrecioBillete()
```

Es importante distinguir entre las cabeceras de los métodos y las declaraciones de los atributos, porque pueden parecer bastante similares. Vemos que `getPrecioBillete` es un método y no un atributo porque las cabeceras de los métodos siempre incluyen una pareja de paréntesis y no incluyen punto y coma al final de la cabecera.

El cuerpo del método es el resto del método, es decir, el código situado después de la cabecera.  Siempre se encierran entre un par de llaves. Los cuerpos de los métodos contienen las *declaraciones* y las *instrucciones* que definen lo que hace un objeto cuando se invoca ese método. Las declaraciones se utilizan para crear espacio adicional para variables temporales, mientras que las instrucciones describen las acciones que realiza el método. En el método `getPrecioBillete` el cuerpo del método contiene una única instrucción, pero pronto veremos ejemplos en los que el cuerpo del método está compuesto por múltiples líneas tanto de declaraciones como de instrucciones.

Cualquier conjunto de declaraciones e instrucciones situado entre una pareja de llaves se conoce con el nombre de *bloque*.  Por tanto, el cuerpo de la clase `MaquinaExpendedoraSimple` y los cuerpos del constructor y de todos los métodos de la clase son bloques.

Existen al menos dos diferencias significativas entre las cabeceras del constructor `MaquinaExpendedoraSimple` y del método `getPrecioBillete`:

```java
public MaquinaExpendedoraSimple(int precioDelBillete, String origen, String destino)
public int getPrecioBillete()
```

* El método tiene un tipo de retorno `int`,  mientras que el constructor no tiene ningún tipo de retorno. el tipo de retorno se escribe justo delante del nombre del método. Esta diferencia se aplica en todos los casos.

* El constructor tiene tres parámetros, mientras que el método no tiene ninguno. Esta es una diferencia que se aplica en este caso concreto.

En java, una regla que se aplica de manera general es que los constructores no pueden tener un tipo de retorno.  Por otro lado, tanto los constructores como los métodos pueden tener cualquier número de parámetros, incluyendo ninguno.

Dentro del cuerpo de `getPrecioBillete` hay una única instrucción:

```java
return precioBillete;
```

Está instrucción se denomina *instrucción de retorno* (*return*) y es la responsable de devolver un valor entero que se corresponda con el tipo de retorno `int` especificado en la cabecera del método. Cuando un método contiene una instrucción de retorno, esta será siempre la instrucción final de dicho método, porque una vez que se ejecute esa instrucción de retorno no se podrá ejecutar ninguna instrucción adicional en ese método.

Los tipos de retorno y las instrucciones de retorno funcionan conjuntamente. El tipo de retorno `int` de `getPrecioBillete`  es una especie de promesa de que el cuerpo del método llevará a cabo algún tipo de acción que terminará por hacer que se calcule un valor entero y que se devuelva como resultado del método. En cierto modo, podemos pensar en que una llamada a un método es una especie de pregunta que se le hace a un objeto y el valor de retorno del método es la respuesta que el objeto da a esa pregunta. En este caso, cuando se invoca el método `getPrecioBillete` en una máquina expendedora, la pregunta sería: *¿Cuánto cuestan los billetes?* Una máquina expendedora no necesita realizar ningún cálculo para ser capaz de responder a esta pregunta, ya que tiene almacenada la respuesta en su atributo `precioBillete`, por lo que el método responde simplemente devolviendo el valor de esa variable.  A medida que desarrollemos clases más complejas, nos encontraremos inevitablemente con preguntas más complicadas que requerirán más trabajo para proporcionar la respuesta.


